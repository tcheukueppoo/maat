# WSF of the Maat Programming Language

* `{X}` stands for 0 or more of `X`.
* `[X]` implies `X` is optional.
* `|` stands for alternation.
* `(X)` for grouping, `X` is considered a single unit.

```
Block = "{" [ Stats ] "}" .

Stats = { NonBlockStat end { end } | BlockStat } [ NonBlockStat ] .

NonBlockStat =   unimpl
               | Package
               | Use
               | Load
               | VarDef
               | Exp
               | StatMod
               | LoopCtrl
               | DeferExpList
               | OnceExpList
               | Return .

BlockStat =   PackageBlock
            | Label
            | Loop
            | Flow
            | Fn
            | Class
            | Role
            | Try
            | DeferBlock
            | OnceBlock .

Package      = "package" namespace .
PackageBlock = Package Block .

Label = name ":" .

Use = "use" namespace [ "(" [ name { "," name } ] ")" ] .

Load = "load" string_lit .

ExpList = Exp { Commas Exp } { "," } .

Commas = "," { "," } .

VarDef = ( [ "const" ] ( Scope | "state" ) Names | "const" Names | "temp" AnyNames ) [ "=" Exp ] .
Scope  = "export" [ "?" ] "our" | "let" .

Names = "(" NameList ")" | name [ im ] .

NameList = { Name_ } [ "*" ] name [ im ] { _Name } { "," } .

Name_ =        name [ im ] Commas .
_Name = Commas name [ im ] .

AnyNames = "(" AnyNameList ")" | any_name [ im ] .

AnyNameList = { AnyName_ } [ "*" ] any_name [ im ] { _AnyName } { "," } .

AnyName_ =        any_name [ im ] Commas .
_AnyName = Commas any_name [ im ] .

Flow =   "when"   Cond              Block
       | "unless" Cond [ TopicVar ] Block { elseif Cond [ TopicVar ] Block } [ else Block ]
       | "if"     Cond [ TopicVar ] Block { elseif Cond [ TopicVar ] Block } [ else Block ]
       | "with"   Cond [ TopicVar ] Block { orwith Cond [ TopicVar ] Block } [ else Block ] .

Cond     = ExpList .
TopicVar = "->" name .

StatMod = ExpList ( cond_keyword | loop_keyword ) Cond .

OnceBlock   = "once" Block .
OnceExpList = "once" ExpList .

DeferBlock   = "defer" Block .
DeferExpList = "defer" ExpList .

Return = return ExpList .

Loop =   ForLoop
       | "loop"  [ LoopCondStats ] Block
       | "while"   Cond            Block
       | "until"   Cond            Block .

ForLoop    = "for" ExpList [ TopicVars ] Block .
TopicVars  = "->" name [ DefaultVal ] { "," name [ DefaultVal ] } .
DefaultVal = ( "=" | "=//" ) Exp .

LoopCondStats = "(" [ ExpList ] ";" [ ExpList ] ";" [ ExpList ] ")" .

LoopCtrl = ( "break" | "next" | "redo" | "goto" ) [ name | loop_id ] .

Try = "try" Block { "catch" Exp Block } [ "finally" Block ] .

Fn     = [ "const" ] [ Scope ] [ "mul" ] "fn" name [ "(" [ FnArgs ] ")" ] [ ":save" | ":gen" ] FnBody .
FnBody = Block .
FnArgs =   NormArg { "," NormArg } [ "," AccArg ] [ "," MapArg ]
         | AccArg "," MapArg
         | AccArg
         | MapArg .

NormArg = name [ DefaultVal ] .
AccArg  =     "*" name .
HashArg = "*" "*" name .

Class = [ "const" ] [ Scope ] "class" name { Is | Does } [ main ] ClassBody .

Is   = ":is"   IsArg .
Does = ":does" DoesArg .

DoesArg = IsArg .
IsArg   = RelClass { "," RelClass } .

RelClass = any_name | fq_name_main | PrefixExp .

ClassBody = "{" ( FieldAndOthers | FieldAndOthers end { end } MethsAndOthers ) "}" .

FieldAndOthers    = { ClassNonBlockStat end { end } | BlockStat      } [ ClassNonBlockStat ] .
MethsAndOthers    = { NonBlockStat      end { end } | ClassBlockStat } [ NonBlockStat      ] .
ClassBlockStat    = Meth  | BlockStat .
ClassNonBlockStat = Field | NonBlockStat .

Field = "field" name [ ":rw" | ":ro" | ":built" ] [ DefaultVal ] .

Meth     = [ "mul" ] "meth" ( "<" custom_op ">" | name [ "(" [ FnArgs ] ")" ] ) [ ":io" ] MethBody .
MethBody = FnBody .

Role     = [ "const" ] [ Scope ] "role" name { Does } [ main ] RoleBody .
RoleBody = ClassBody .

Exp =   nil_lit
      | bool_lit
      | number_lit
      | string_lit
      | regex_lit
      | Var
      | VarAssign
      | AnonyFn
      | Array
      | Map
      | VarDef
      | PrefixExp
      | PostfixExp
      | SmartMatch
      | Exp infix_op Exp
      | Exp postfix_op
      | prefix_op Exp
      | StatExp .

PostfixExp =   Tenary
             | RegexMatch
             | RegexSmartMatch
             | RegexSub
             | RegexTr
             | OpRegexMatch
             | OpRegexSub
             | OpRegexTr .

Tenary   = Exp OpTenary .
OpTenary = "?" ExpList ":" ExpList .
           
RegexMatch      = Exp regex_sign OpRegexMatch .
RegexSmartMatch = Exp smartmatch_sign OpRegexMatch.  
RegexSub        = Exp regex_sign OpRegexSub .
RegexTr         = Exp regex_sign OpRegexTr .

OpRegexMatch = regex_q_p | ( "m" delim__r_q__delim | sl__r_q__sl ) m_regex_modifer .
OpRegexSub   = "s"  OpRegexSubArg s_regex_modifier .
OpRegexTr    = "tr" OpRegexTrArg  tr_regex_modifier .

OpRegexTrArg  = RegexSubArg .
OpRegexSubArg =   r_q__single_char_delim
                | d_q__pair_delim   delim__r_q__delim
                | delim__r_q__delim d_q__pair_delim .

Var          = any_name | fq_name_main | object_field | ArrayElement | MapEntry .
ArrayElement = Exp "[" ExpList "]" .
MapEntry     = Exp ( o_lab uni_e_rab { uni_e_rab } c_rab | "{" ExpList "}" ) .

VarAssign = 

PrefixExp  = GroupExp | FnCall .
GroupExp   = "(" ExpList ")" .
FnCall     = Exp [ "(" [ FnCallArgs ] ")" | FnCallArgs ].
FnCallArgs = 

AnonyFn = [ "fn" ] "{" [ "|" FnArgs "|" ] [ Stats ] "}" .

Array        = ArrayDefault | ArrayQuoted .
ArrayDefault = "[" [ ExpList ] "]" .
ArrayQuoted  = "%a" ArrayPairTokensPair .

ArrayPairTokensPair =   o_cb    { uni_e_cb    } c_cb
                      | o_pr    { uni_e_pr    } c_pr
                      | o_sb    { uni_e_sb    } c_sb
                      | o_lab   { uni_e_rab   } c_rab
                      | o_labq  { uni_e_rabq  } c_rabq
                      | o_ldabq { uni_e_rdabq } c_rdabq
                      | s_em    { uni_e_em    } s_em
                      | s_bq    { uni_e_bq    } s_bq
                      | s_vb    { uni_e_vb    } s_vb
                      | s_dq    { uni_e_dq    } s_dq
                      | s_sq    { uni_e_sq    } s_sq
                      | s_sl    { uni_e_sl    } s_sl
                      | s_cm    { uni_e_cm    } s_cm .

Map        = MapDefault | MapQuoted .
MapDefault = "{" [ Exp "=>" Exp { Commas Exp "=>" Exp } { "," } ] "}" .
MapQuoted  = "%m" MapPairTokensPair .

MapPairTokensPair =   o_cb    { uni_e_cb    uni_e_cb    } c_cb
                    | o_pr    { uni_e_pr    uni_e_pr    } c_pr
                    | o_sb    { uni_e_sb    uni_e_sb    } c_sb
                    | o_lab   { uni_e_rab   uni_e_rab   } c_rab
                    | o_labq  { uni_e_rabq  uni_e_rabq  } c_rabq
                    | o_ldabq { uni_e_rdabq uni_e_rdabq } c_rdabq
                    | s_em    { uni_e_em    uni_e_em    } s_em
                    | s_bq    { uni_e_bq    uni_e_bq    } s_bq
                    | s_vb    { uni_e_vb    uni_e_vb    } s_vb
                    | s_dq    { uni_e_dq    uni_e_dq    } s_dq
                    | s_sq    { uni_e_sq    uni_e_sq    } s_sq
                    | s_sl    { uni_e_sl    uni_e_sl    } s_sl
                    | s_cm    { uni_e_cm    uni_e_cm    } s_cm .

StatExp = DoStatExp | MaStatExp .

DoStatExp = "do" ( Loop    | Flow   ) .
MaStatExp = "ma" ( ForLoop | FnCall ) .

--- Below is the WSN of all lexical tokens ---

end    = ";" .
unimpl = "…" | "..." .

im   = ":" "im" .
main = ":" "main" .

regex_sign      = "=~" | "≅" .
smartmatch_sign = "~~" .

loop_keyword = "for" | "until"  | "while" .
cond_keyword = "if"  | "unless" | "when" | "with" .

special_name = spec_lex_scoped | spec_main_package .

spec_lex_scoped   = dec_int | "N"  | "*" | "." .
spec_main_package =   "V"   | "O"  | "," | "/"
                    | "|"   | """" | "@" | "0"
                    | "("   | "<"  | "F" | "*"
                    | "."   | "!" .


name =  .

namespace    = name { "::" name } .
fq_name      = namespace "::" name .
fq_name_main = [ namespace ] ":::" name .

special_name = "@" ( "{" special_name "}" | special_name ) .
any_name     = name | fq_name | special_name .

object_field = name "." name .

infix_op =   "="  | "."   | ".^"  | "!."  | "!.^" | ","  | "=>"
           | "//" | "=="  | "⩵"   | "===" | "⩶ "  | "!=" | "≠"
           | ">"  | ">="  | "≥"   | "<"   | "<="  | "≤"  | "+"
           | "-"  | "/"   | "÷"   | "*"   | "%"   | ".." | "+="
           | "/=" | "÷="  | "-="  | "//=" | "*="  | "%=" | "<<"
           | ">>" | "^"   | "&"   | "|"   | "^="  | "&=" | "|="
           | "&&" | "||"  | "&&=" | "||=" | "∉"   | "∈"  | "∋"
           | "∌"  | "⊂"   | "⊄"   | "⊆"   | "⊈"   | "⊃"  | "⊅"
           | "⊇"  | "⊉"   | "≡"   | "≢"   | "⊖"   | "∩"  | "⊍"
           | "∪"  | "⊖"   | "⊎"   | "∖"   | "<=>" | "∘"  | "<-"
           | "~~" .

postfix_op = .

prefix_op = ":" .

regex_mod   = "i" | "m" | "s" | "a" | "n" | "x" | "xx" .
s_regex_mod = regex_mod | "g" | "e" | "c"
y_regex_mod = regex_mod | "d"
m_regex_mod = regex_mod 

nil_lit  = "nil" .
bool_lit = "true" | "false" .

dec_digit      = "0" | non_zero_digit .
non_zero_digit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" .
bin_digit      = "0" | "1" .
oct_digit      = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" .
hex_digit      = dec_digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" .

num_lit = int_lit | float_lit .

int_lit = bin_int | oct_int | dec_int | hex_int .

dec_int = "0" | non_zero_digit [ [ "_" ] dec_digits ] .
bin_int = "0" ( "b" | "B" ) [ "_" ] bin_digit { [ "_" ] bin_digit } .
oct_int = "0" [ "o" | "O" ] [ "_" ] oct_digit { [ "_" ] oct_digit } .
hex_int = "0" ( "x" | "X" ) [ "_" ] hex_digits .

dec_digits = dec_digit { [ "_" ] dec_digit } .
hex_digits = hex_digit { [ "_" ] hex_digit } .

float_lit = hex_float | dec_float .

dec_float =   dec_int [ "." [ dec_digits ] ]   dec_expo
            | dec_int                          dec_expo
            |           "."   dec_digits     [ dec_expo ] .
dec_expo  = ( "e" | "E" ) [ "-" | "+" ] dec_digits .

hex_float    = "0" ( "x" | "X" ) hex_mantissa ( "p" | "P" ) [ "-" | "+" ] dec_digits .
hex_mantissa =   [ "_" ] hex_digits "." [ hex_digits ]
               | [ "_" ] hex_digits
               |                    "."   hex_digits .

o_cb    = "{" .   c_cb    = "}" .   e_cb    = "\" "}" .
o_pr    = "(" .   c_pr    = ")" .   e_pr    = "\" ")" .
o_sb    = "[" .   c_sb    = "]" .   e_sb    = "\" "]" .
o_lab   = "<" .   c_rab   = ">" .   e_rab   = "\" ">" .
o_ldabq = "«" .   c_rdabq = "»" .   e_rdabq = "\" "»" .
o_labq  = "‹" .   c_rabq  = "›" .   e_rabq  = "\" "›" .

s_em = "!"  .   e_em = "\" "!"  .
s_bq = "`"  .   e_bq = "\" "`"  .
s_vb = "|"  .   e_vb = "\" "|"  .
s_dq = """" .   e_bq = "\" """" .
s_sq = "'"  .   e_sq = "\" "'"  .
s_sl = "/"  .   e_sl = "\" "/"  .
s_cm = ","  .   e_cm = "\" ","  .

string_lit = str_default | str_q_with_delim | here_doc .

str_default = single_q | double_q | back_q .

single_q = s_sq { val_single_q } s_sq .
double_q = s_dq { val_double_q } s_dq .
back_q   = s_bq { val_double_q } s_bq .

val_double_q = vdq .
val_single_q = vsq .

vsq = esc_sq_char     | uni_codepoint_utf8_enc .
vdq = exp_interpolate | esc_char | ascii_codepoint | uni_codepoint | uni_codepoint_utf8_enc .

exp_interpolate = special_name | "#" ( "{" Exp "}" | Var ) .

esc_sq_char = "\" "'" .
esc_char    = "\" ( "#" | "@" | "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\" | """" ) .

ascii_codepoint = "\" "x" hex_digit _hex_digit .
_hex_digit      = [ "_" ] hex_digit .

uni_codepoint  = uni_u_val | uni_n_val .
uni_u_val      = "\" "u" ( hex_digit _hex_digit | "{" codepoint "}" ) .
uni_n_val      = "\" "N" "{" ( "U" "+" codepoint ) | normative_name "}" .
normative_name = 

codepoint =   hex_digit      _hex_digit   [ _hex_digit ] [ _hex_digit ]
            [ _hex_digit ] [ _hex_digit ] [ _hex_digit ] [ _hex_digit ] .

uni_codepoint_utf8_enc = well_formed_utf8_byte_seq | ill_formed_utf8_byte_seq .
well_formed_utf8_byte_seq  = --- --- .
ill_formed_utf8_byte_seq   = --- --- .

str_q_with_delim = single_q_p | double_q_p | back_q_p | regex_q_p .

single_q_p = "%" "q" delim__s_q__delim .
double_q_p = "%" "Q" delim__d_q__delim .
back_q_p   = "%" "x" delim__b_q__delim .
regex_q_p  = "%" "r" delim__r_q__delim .

delim__d_q__delim = _delim__d_q__delim | sq__d_q__sq .
sq__d_q__sq       = s_sq { vdq | e_sq } s_sq .

_delim__d_q__delim = d_q__single_char_delim | d_q__pair_delim .

d_q__single_char_delim =   s_em { vdq | e_em } s_em
                         | s_bq { vdq | e_bq } s_bq
                         | s_vb { vdq | e_vb } s_vb
                         | s_dq { vdq        } s_dq
                         | s_sl { vdq | e_sl } s_sl
                         | s_cm { vdq | e_cm } s_cm .

d_q__pair_delim =   o_cb    { vdq | e_cb    } c_cb
                  | o_pr    { vdq | e_pr    } c_pr
                  | o_sb    { vdq | e_sb    } c_sb
                  | o_lab   { vdq | e_rab   } c_rab
                  | o_labq  { vdq | e_labq  } c_labq .
                  | o_ldabq { vdq | e_rdabq } c_rdabq

delim__b_q__delim = delim__d_q__delim | sq__b_q__sq .
sq__b_q__sq       = sq__s_q__sq .
sq__s_q__sq       = s_sq { vsq } s_sq .

delim__r_q__delim = ( _delim__d_q__delim | sq__r_q__sq ) [ regex_modifier ] .
sq__r_q__sq       = sq__s_q__sq .
sl__r_q__sl       = s_sl { vdq | e_sl } s_sl .

sq__r_q__sq__r_q__sq = sq__s_q__sq { vsq } s_sq .

r_q__single_char_delim =   s_em { vdq | e_em } s_em { vdq | e_em } s_em
                         | s_bq { vdq | e_bq } s_bq { vdq | e_bq } s_bq
                         | s_vb { vdq | e_vb } s_vb { vdq | e_vb } s_vb
                         | s_dq { vdq | e_dq } s_dq { vdq | e_dq } s_dq
                         | s_sq { vdq        } s_sq { vdq        } s_sq
                         | s_sl { vdq | e_sl } s_sl { vdq | e_sl } s_sl
                         | s_cm { vdq | e_cm } s_cm { vdq | e_cm } s_cm .

delim__s_q__delim = s_q__single_char_delim | s_q__pair_delim .

s_q__single_char_delim =   s_em { vsq | e_em } s_em
                         | s_bq { vsq | e_bq } s_bq
                         | s_vb { vsq | e_vb } s_vb
                         | s_dq { vsq | e_dq } s_dq
                         | s_sq { vsq        } s_sq
                         | s_sl { vsq | e_sl } s_sl
                         | s_cm { vsq | e_cm } s_cm .

s_q__pair_delim =   o_cb    { vsq | e_cb    } c_cb
                  | o_pr    { vsq | e_pr    } c_pr
                  | o_sb    { vsq | e_sb    } c_sb
                  | o_lab   { vsq | e_rab   } c_rab
                  | o_labq  { vsq | e_rabq  } c_rabq .
                  | o_ldabq { vsq | e_rdabq } c_rdabq

here_doc    = hd_no_q | hd_single_q | hd_double_q | hd_back_q .
hd_no_q     = "<<"      tok      nl vsq nl tok .
hd_single_q = "<<" "'"  tok "'"  nl vsq nl tok .
hd_double_q = "<<" """" tok """" nl vdq nl tok .
hd_back_q   = "<<" "`"  tok "`"  nl vsq nl tok .
tok         = name .

generic_nl      = [ carriage_return ] new_line .
carriage_return = --- UTF-8-encoded unicode codepoint U+XXXX --- .
new_line        = --- UTF-8-encoded unicode codepoint U+XXXX --- .

uni_e_cb    = ( uni___space__cb    | e_cb    ) { uni___space__cb    | e_cb    } .
uni_e_pr    = ( uni___space__pr    | e_pr    ) { uni___space__pr    | e_pr    } .
uni_e_sb    = ( uni___space__sb    | e_sb    ) { uni___space__sb    | e_sb    } .
uni_e_rab   = ( uni___space__rab   | e_rab   ) { uni___space__rab   | e_rab   } .
uni_e_rabq  = ( uni___space__rabq  | e_rabq  ) { uni___space__rabq  | e_rapq  } .
uni_e_rdabq = ( uni___space__rdabq | e_rdabq ) { uni___space__rdabq | e_rdabq } .
uni_e_em    = ( uni___space__em    | e_em    ) { uni___space__em    | e_em    } .
uni_e_bq    = ( uni___space__bq    | e_bq    ) { uni___space__bq    | e_bq    } .
uni_e_vb    = ( uni___space__vb    | e_vb    ) { uni___space__vb    | e_vb    } .
uni_e_dq    = ( uni___space__dq    | e_dq    ) { uni___space__dq    | e_dq    } .
uni_e_sq    = ( uni___space__sq    | e_sq    ) { uni___space__sq    | e_sq    } .
uni_e_sl    = ( uni___space__sl    | e_sl    ) { uni___space__sl    | e_sl    } .
uni_e_cm    = ( uni___space__cm    | e_cm    ) { uni___space__cm    | e_cm    } .

uni___space__cb    = --- UTF-8-encoded unicode codepoint except U+0020 and U+007D --- .
uni___space__pr    = --- UTF-8-encoded unicode codepoint except U+0020 and U+0029 --- .
uni___space__sb    = --- UTF-8-encoded unicode codepoint except U+0020 and U+005D --- .
uni___space__rab   = --- UTF-8-encoded unicode codepoint except U+0020 and U+003E --- .
uni___space__rabq  = --- UTF-8-encoded unicode codepoint except U+0020 and U+203A --- .
uni___space__rdabq = --- UTF-8-encoded unicode codepoint except U+0020 and U+00BB --- .
uni___space__em    = --- UTF-8-encoded unicode codepoint except U+0020 and U+0021 --- .
uni___space__bq    = --- UTF-8-encoded unicode codepoint except U+0020 and U+0060 --- .
uni___space__vb    = --- UTF-8-encoded unicode codepoint except U+0020 and U+007C --- .
uni___space__dq    = --- UTF-8-encoded unicode codepoint except U+0020 and U+0022 --- .
uni___space__sq    = --- UTF-8-encoded unicode codepoint except U+0020 and U+0027 --- .
uni___space__sl    = --- UTF-8-encoded unicode codepoint except U+0020 and U+002F --- .
uni___space__cm    = --- UTF-8-encoded unicode codepoint except U+0020 and U+002C --- .

```

An expession is a special case of statement that returns a value.

say ((2,,,4) + 1) # outputs 5 it implies that an expression list is an expression and ',' is an infix operator.
say ((2,,) + 1)   # outputs 3, is ',' also a postfix operator?

# ambiguity
1. loop (); k; k { }
2. exp, exp, exp if exp, exp, exp ... === exp, exp, exp if (exp, exp, exp ...)
3. hex_float (_.)
4. code_interpolation
5. =~ is not an infix operator

`PostfixExp` isn't solely dedicated to regexes but it turns out that regexes are
the only postfix expressions of this kind. Also, the presence of `RegexMatch`,
`RegexSub` and `RegexTrans` as possible values to `PostfixExp` is due to the
fact that a regex expression starting with its left operand implies the
operation is done on the default topic variable `_`, for instance an expression
starting with `/^Ku.p{2}[0o]/` is equivalent to `_ =~ /^Ku.p{2}[0o]/`.

The reason why the regex operator `=~` isn't a normal infix operator like its
brothers is due to the designed decisions of the compiler and also how exactly
regular expressions are used in Maat


