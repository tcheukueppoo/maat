# WSF of the Maat Programming Language

* `{X}` stands for 0 or more of `X`.
* `[X]` implies `X` is optional.
* `|` stands for alternation.
* `(X)` for grouping, `X` is considered a single unit.

```
Block = "{" [ Stats ] "}" .

Stats = { NonBlockStat end { end } | BlockStat } [ NonBlockStat ] .

NonBlockStat =   unimpl
               | Package
               | Use
               | Load
               | VarDef
               | Exp
               | StatMod
               | LoopCtrl
               | DeferExpList
               | OnceExpList
               | Return .

BlockStat =   PackageBlock
            | Label
            | Loop
            | Flow
            | Fn
            | Class
            | Role
            | Try
            | DeferBlock
            | OnceBlock .

Package      = "package" namespace .
PackageBlock = Package Block .

Label = name ":" .

Use = "use" namespace [ "(" [ name { "," name } ] ")" ] .

Load = "load" string_lit .

ExpList = Exp { Commas Exp } { "," } .

Commas = "," { "," } .

VarDef = ( [ "const" ] ( [ scope ] | "state" ) Vars | "const" Vars | "temp" AnyVars ) [ EqExp ] .

EqExp = "=" Exp .

Vars    = "(" VarList { "," } ")" | var .
VarList = { Var_ } [ "*" ] var [ im ] { _Var } .

Var_ =        var [ im ] Commas .
_Var = Commas var [ im ] .

AnyVars    = "(" AnyVarList ")" | any_var .
AnyVarList = { AnyVar_ } [ "*" ] any_var [ im ] { _AnyVar } { "," } .

AnyVar_ =        any_var [ im ] Commas .
_AnyVar = Commas any_var [ im ] .

Flow =   "given"  Cond [ TopicVar ] Block
       | "when"   Cond              Block
       | "unless" Cond [ TopicVar ] Block { elseif Cond [ TopicVar ] Block } [ else Block ]
       | "if"     Cond [ TopicVar ] Block { elseif Cond [ TopicVar ] Block } [ else Block ]
       | "with"   Cond [ TopicVar ] Block { orwith Cond [ TopicVar ] Block } [ else Block ] .

TopicVar = "->" var .

Cond = ExpList .

StatMod = ExpList ( cond_keyword | loop_keyword ) Cond .

OnceBlock   = "once" Block .
OnceExpList = "once" ExpList .

DeferBlock   = "defer" Block .
DeferExpList = "defer" ExpList .

Return = return ExpList .

Loop =   ForLoop
       | "loop"  [ LoopCondStats ] Block
       | "while"   Cond            Block
       | "until"   Cond            Block .

ForLoop = "for" ExpList [ TopicVars ] Block .

LoopCondStats = "(" [ ExpList ] ";" [ ExpList ] ";" [ ExpList ] ")" .

LoopCtrl = ( "break" | "next" | "redo" | "goto" ) [ name | loop_id ] .

TopicVars = "->" var [ EqExp ] { "," var [ EqExp ] } .

Try = "try" Block { "catch" Exp Block } [ "finally" Block ] .

Fn = [ "const" ] [ scope ] [ "mul" ] "fn" name [ "(" [ FnArgs ] ")" ] [ ":s" | ":g" ] FnBody .

FnArgs =   NormArg { "," NormArg } [ "," AccArg ] [ "," MapArg ]
         | AccArg "," MapArg
         | AccArg
         | MapArg .

NormArg = var [ ( "=" | "=//" ) Exp ] .
AccArg  = "*"     var .
HashArg = "*" "*" var .

FnBody = Block .

Class    = [ "const" ] [ scope ] "class" name [ ClassRel ] [ main ] ClassBody .
ClassRel = Is Does | Does Is | Is | Does .

Is   = ":is("   [ IsArgs   ] ")" .
Does = ":does(" [ DoesArgs ] ")" .

DoesArgs = IsArgs .

IsArgs   = RelClass { "," RelClass } .
RelClass = any_name | fq_name_main | PrefixExp .

ClassBody = "{" ( FieldWithOthers | FieldWithOthers end { end } MethsWithOthers ) "}" .

FieldWithOthers   = { ClassNonBlockStat end { end } | BlockStat      } [ ClassNonBlockStat ] .
MethsWithOthers   = { NonBlockStat      end { end } | ClassBlockStat } [ NonBlockStat      ] .
ClassNonBlockStat = Field | NonBlockStat .
ClassBlockStat    = Meth  | BlockStat .

Field = "field" name [ ":rw" | ":ro" | ":built" ] [ EqExp ] .

Meth     = [ "mul" ] "meth" ( "<" custom_op ">" | name [ "(" [ FnArgs ] ")" ] ) [ ":io" ] MethBody .
MethBody = FnBody .

Role     = [ "const" ] [ scope ] "role" name [ Does ] [ main ] RoleBody .
RoleBody = ClassBody .

Exp =   nil_lit
      | bool_lit
      | number_lit
      | string_lit
      | regex_lit
      | PrefixExp
      | AnonyFn
      | Array
      | Map
      | VarDef
      | Exp infix_op Exp
      | Exp postfix_op
      | prefix_op Exp
      | StatExp

AnonyFn = [ "fn" ] "{" [ "|" FnArgs "|" ] [ Stats ] "}" .

Map        = MapDefault | MapQuoted .
MapDefault = "{" [ Exp "=>" Exp { Commas Exp "=>" Exp } { "," } ] "}" .
MapQuoted  = "@m" MapPairTokensPair .

MapPairTokenspair =   o_cb    { uni__e_cb    uni__e_cb    } c_cb    | o_pr   { uni__e_pr   uni__e_pr   } c_pr
                    | o_sb    { uni__e_sb    uni__e_sb    } c_sb    | o_lab  { uni__e_rab  uni__e_rab  } c_rab
                    | o_ldabq { uni__e_rdabq uni__e_rdabq } c_rdabq | o_labq { uni__e_rabq uni__e_rabq } c_rabq
                    | s_em    { uni__e_em    uni__e_em    } s_em    | s_bq   { uni__e_bq   uni__e_bq   } s_bq
                    | s_dl    { uni__e_dl    uni__e_dl    } s_dl    | s_vb   { uni__e_vb   uni__e_vb   } s_vb
                    | s_dq    { uni__e_dq    uni__e_dq    } s_dq    | s_sq   { uni__e_sq   uni__e_sq   } s_sq
                    | s_sl    { uni__e_sl    uni__e_sl    } s_sl    | s_cm   { uni__e_cm   uni__e_cm   } s_cm .

Array        = ArrayDefault | ArrayQuoted .
ArrayDefault = "[" [ ExpList ] "]" .
ArrayQuoted  = "@a" ArrayPairTokensPair .

ArrayPairTokenspair =   o_cb    { uni__e_cb    } c_cb    | o_pr   { uni__e_pr   } c_pr
                      | o_sb    { uni__e_sb    } c_sb    | o_lab  { uni__e_rab  } c_rab
                      | o_ldabq { uni__e_rdabq } c_rdabq | o_labq { uni__e_rabq } c_rabq
                      | s_em    { uni__e_em    } s_em    | s_bq   { uni__e_bq   } s_bq
                      | s_dl    { uni__e_dl    } s_dl    | s_vb   { uni__e_vb   } s_vb
                      | s_dq    { uni__e_dq    } s_dq    | s_sq   { uni__e_sq   } s_sq
                      | s_sl    { uni__e_sl    } s_sl    | s_cm   { uni__e_cm   } s_cm .

StatExp = DoStatExp | MaStatExp .

DoStatExp = "do" ( Loop    | Flow   ) .
MaStatExp = "ma" ( ForLoop | FnCall ) .

PrefixExp =  .

--- Below is the WSN of all lexical tokens ---

scope        = "let" | "our" .
loop_keyword = "for" | "until"  | "while" .
cond_keyword = "if"  | "unless" | "unless" | "when" | "with" | "given" .

end = ";" .

infix_op = "," | ":" |

postfix_op = .

prefix_op = .

unimpl = "…" | "..." .

im   = ":" "i" .
main = ":" "m" .

nil_lit  = "nil" .
bool_lit = "true" | "false" .

bin_digit      = "0" | "1" .
non_zero_digit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" .
oct_digit      = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" .
dec_digit      = "0" | non_zero_digit .
hex_digit      = dec_digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" .

num_lit = int_lit | float_lit .

int_lit = bin_int | oct_int | dec_int | hex_int .
bin_int = "0" ( "b" | "B" ) [ "_" ] bin_digit { [ "_" ] bin_digit } .
oct_int = "0" [ "o" | "O" ] [ "_" ] oct_digit { [ "_" ] oct_digit } .
dec_int = "0" | non_zero_digit [ [ "_" ] dec_digits ] .
hex_int = "0" ( "x" | "X" )      [ "_" ] hex_digits .

dec_digits = dec_digit { [ "_" ] dec_digit } .
hex_digits = hex_digit { [ "_" ] hex_digit } .

float_lit = hex_float | dec_float .

dec_float =   dec_int [ "." [ dec_digits ] ]   dec_exp
            | dec_int                          dec_exp
            |           "."   dec_digits     [ dec_exp ] .

dec_exp = ( "e" | "E" ) [ "-" | "+" ] dec_digits .

hex_float    = "0" ( "x" | "X" ) hex_mantissa ( "p" | "P" ) [ "-" | "+" ] dec_digits .
hex_mantissa =   [ "_" ] hex_digits "." [ hex_digits ]
               | [ "_" ] hex_digits
               |                    "."   hex_digits .

o_cb    = "{" . c_cb   = "}"  . o_pr   = "(" . c_pr   = ")" .
o_sb    = "[" . c_sb   = "]"  . o_lab  = "<" . c_rab  = ">" .
o_ldabq = "«" . c_rdabq = "»" . o_labq = "‹" . c_rabq = "›" .

e_cb  = "\" "}" . e_pr    = "\" ")" . e_sb   = "\" "]" .
e_rab = "\" ">" . c_rdabq = "\" "»" . e_rabq = "\" "›" .

s_em = "!"  . s_bq = "`" . s_dl = "$" . s_vb = "|" .
s_dq = """" . s_sq = "'" . s_sl = "/" . s_cm = "," .

e_em = "\" "!"  . e_bq = "\" "`" . s_dl = "\" "$" . e_vb = "\" "|" .
e_bq = "\" """" . e_sq = "\" "'" . e_sl = "\" "/" . e_cm = "\" "," .

string_lit = str_default | str_q_with_pair | here_doc .

str_default = single_q | double_q | back_q .
single_q    = s_sq { val_single_q } s_sq .
double_q    = s_dq { val_double_q } s_dq .
back_q      = s_bq { val_double_q } s_bq .

vdq = val_double_q .
vsq = val_single_q .

vsq = esc_sq_char | unicode_codepoint_utf8_encoded .
vdq = esc_char    | ascii_codepoint | unicode_codepoint | unicode_codepoint_utf8_encoded | var_interpolation .

esc_sq_char = "\" "'" .
esc_char    = "\" ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\" | """" ) .

ascii_codepoint = "\" "x" hex_digit _hex_digit .
_hex_digit      = [ "_" ] hex_digit .

unicode_codepoint = unicode_u_val | unicode_n_val .
unicode_u_val     = "\" "u" ( hex_digit _hex_digit | "{" codepoint "}" ) .
unicode_n_val     = "\" "N" "{" ( "U" "+" codepoint ) | normative_name "}" .
normative_name    = 

codepoint =   hex_digit      _hex_digit   [ _hex_digit ] [ _hex_digit ]
            [ _hex_digit ] [ _hex_digit ] [ _hex_digit ] [ _hex_digit ] .

unicode_codepoint_utf8_encoded = well_formed_utf8_byte_sequence | ill_formed_utf8_byte_sequence .
well_formed_utf8_byte_sequence = --- --- .
ill_formed_utf8_byte_sequence  = --- --- .

var_interpolation = special_var | "#" ( "{" "}" | ) .

str_q_with_pair = "@" ( single_q_p | double_q_p | back_q_p | regex_q_p ) .
single_q_p      = "q" pair__s_q__pair .
double_q_p      = "Q" pair__d_q__pair .
back_q_p        = "x" pair__b_q__pair .
regex_q_p       = "r" pair__r_q__pair .

pair__s_q__pair =   o_cb    { vsq | e_cb    } c_cb    | o_pr   { vsq | e_pr   } c_pr
                  | o_sb    { vsq | e_sb    } c_sb    | o_lab  { vsq | e_rab  } c_rab
                  | o_ldabq { vsq | e_rdabq } c_rdabq | o_labq { vsq | e_rabq } c_rabq
                  | s_em    { vsq | e_em    } s_em    | s_bq   { vsq | e_bq   } s_bq
                  | s_dl    { vsq | e_dl    } s_dl    | s_vb   { vsq | e_vb   } s_vb
                  | s_dq    { vsq | e_dq    } s_dq    | s_sq   { vsq          } s_sq
                  | s_sl    { vsq | e_sl    } s_sl    | s_cm   { vsq | e_cm   } s_cm .

_pair__d_q__pair =   o_cb    { vdq | e_cb    } c_cb    | o_pr   { vdq | e_pr   } c_pr
                   | o_sb    { vdq | e_sb    } c_sb    | o_lab  { vdq | e_rab  } c_rab
                   | o_ldabq { vdq | e_rdabq } c_rdabq | o_lapq { vdq | e_lapq } c_lapq
                   | s_em    { vdq | e_em    } s_em    | s_bq   { vdq | e_bq   } s_bq
                   | s_dl    { vdq | e_dl    } s_dl    | s_vb   { vdq | e_vb   } s_vb
                   | s_dq    { vdq           } s_dq    | s_sl   { vdq | e_sl   } s_sl
                   | s_cm    { vdq | e_cm    } s_cm .

pair__d_q__pair = _pair__d_q__pair | s_sq { vdq | e_sq } s_sq .
pair__b_q__pair = pair__d_q__pair .

pair__r_q__pair = ( _pair__d_q__pair | s_sq { vsq | e_sq } s_sq ) [ regex_modifier ] .

regex_lit         = regex_default | regex_q_with_pair .
regex_default     = "/" "/" { regex_val_mod } .
regex_q_with_pair = "@r"
regex_val_mod     = "m" | "i" | "s" | "a" | "n" |
regex_s_op_mod    = regex_value_mod | "g" | "e" |


here_doc    = hd_no_q | hd_single_q | hd_double_q | hd_back_q .
hd_no_q     = "<<"      tok      nl vsq nl tok .
hd_single_q = "<<" "'"  tok "'"  nl vsq nl tok .
hd_double_q = "<<" """" tok """" nl vdq nl tok .
hd_back_q   = "<<" "`"  tok "`"  nl vsq nl tok .
tok         = name .

generic_nl = [ carriage_return ] new_line .


uni__e_cb    = ( uni___space__cb    | e_cb    ) { uni___space__cb   | e_cb     } .
uni__e_sb    = ( uni___space__sb    | e_sb    ) { uni___space__sb   | e_sb     } .
uni__e_rdabq = ( uni___space__rdabq | e_rdabq ) { uni___space__rdabq | e_rdabq } .
uni__e_em    = ( uni___space__em    | e_em    ) { uni___space__em   | e_em     } .
uni__e_dl    = ( uni___space__dl    | e_dl    ) { uni___space__dl   | e_dl     } .
uni__e_dq    = ( uni___space__dq    | e_dq    ) { uni___space__dq   | e_dq     } .
uni__e_sl    = ( uni___space__sl    | e_sl    ) { uni___space__sl   | e_sl     } .
uni__e_pr    = ( uni___space__pr    | e_pr    ) { uni___space__pr   | e_pr     } .
uni__e_rab   = ( uni___space__rab   | e_rab   ) { uni___space__rab  | e_rab    } .
uni__e_lapq  = ( uni___space__lapq  | e_lapq  ) { uni___space__lapq | e_lapq   } .
uni__e_bq    = ( uni___space__bt    | e_bq    ) { uni___space__bt   | e_bq     } .
uni__e_vb    = ( uni___space__vb    | e_vb    ) { uni___space__vb   | e_vb     } .
uni__e_sq    = ( uni___space__sq    | e_sq    ) { uni___space__sq   | e_sq     } .
uni__e_cm    = ( uni___space__cm    | e_cm    ) { uni___space__cm   | e_cm     } .

uni___space__cb    = --- utf8 encoded unicode codepoint except U+0020 and U+007D --- .
uni___space__sb    = --- utf8 encoded unicode codepoint except U+0020 and U+005D --- .
uni___space__rdabq = --- utf8 encoded unicode codepoint except U+0020 and U+00BB --- .
uni___space__em    = --- utf8 encoded unicode codepoint except U+0020 and U+0021 --- .
uni___space__dl    = --- utf8 encoded unicode codepoint except U+0020 and U+0024 --- .
uni___space__dq    = --- utf8 encoded unicode codepoint except U+0020 and U+0022 --- .
uni___space__sl    = --- utf8 encoded unicode codepoint except U+0020 and U+002F --- .
uni___space__pr    = --- utf8 encoded unicode codepoint except U+0020 and U+0029 --- .
uni___space__rab   = --- utf8 encoded unicode codepoint except U+0020 and U+003E --- .
uni___space__rabq  = --- utf8 encoded unicode codepoint except U+0020 and U+203A --- .
uni___space__bq    = --- utf8 encoded unicode codepoint except U+0020 and U+0060 --- .
uni___space__vb    = --- utf8 encoded unicode codepoint except U+0020 and U+007C --- .
uni___space__sq    = --- utf8 encoded unicode codepoint except U+0020 and U+0027 --- .
uni___space__cm    = --- utf8 encoded unicode codepoint except U+0020 and U+002C --- .

special_char =   "V" | "O" | ","
               | "/" | "|" | """"
               | "$" | "0" | "("
               | "<" | "F" | "*"
               | "." | "!" | "$" .

name = 

var = name .

namespace = name { "::" name } .

fq_var      = namespace "::" name .
fq_var_main = [ namespace ] ":::" name .

special_var = "$" special_char .
any_var     = var | fq_var | special_var .
```

An expession is a special case of statement that returns a value.

say ((2,,,4) + 1) # outputs 5 it implies that an expression list is an expression and ',' is an infix operator.
say ((2,,) + 1)   # outputs 3, is ',' also a postfix operator?

# ambiguity
loop (); k; k { }
exp, exp, exp if exp, exp, exp ... === exp, exp, exp if (exp, exp, exp ...)
hex_float (_.)
