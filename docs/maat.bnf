# WSF of the Maat Programming Language

* `{X}` stands for 0 or more of `X`.
* `[X]` implies `X` is optional.
* `|` stands for alternation.
* `(X)` for grouping, `X` is considered a single unit.

```
Block = "{" [ Stats ] "}" .

Stats = { NonBlockStat end { end } | BlockStat } [ NonBlockStat ] .

NonBlockStat =   unimpl
               | Package
               | Use
               | Load
               | VarDef
               | Exp
               | StatMod
               | LoopCtrl
               | DeferExp
               | Return .

BlockStat =   PackageBlock
            | Label
            | Loop
            | Flow
            | Fn
            | Class
            | Role
            | Try
            | DeferBlock .

Package      = "package" namespace .
PackageBlock = Package Block .

Label = name ":" .

Use = "use" namespace [ "(" [ name { "," name } ] ")" ] .

Load = "load" string_lit .

Commas = "," { "," } .

ExpList = Exp { Commas Exp } { "," } .

VarDef = ( [ "const" ] ( [ scope ] | "state" ) Vars | "const" Vars | "temp" AnyVars ) [ EqExp ] .

EqExp = "=" Exp .

Vars    = "(" VarList { "," } ")" | var .
VarList = { Var_ } [ "*" ] var [ im ] { _Var } .
_Var    = Commas var [ im ] .
Var_    = var        [ im ] Commas .

AnyVars    = "(" AnyVarList { "," } ")" | any_var .
AnyVarList = { AnyVar_ } [ "*" ] any_var [ im ] { _AnyVar } .
_AnyVar    = Commas any_var [ im ] .
AnyVar_    = any_var        [ im ] Commas .

Flow =   "given" CtrlExp [ TopicVar ] Block
       | "when"  CtrlExp              Block
       | "if"    CtrlExp [ TopicVar ] Block { elseif CtrlExp [ TopicVar ] Block } [ else Block ]
       | "with"  CtrlExp [ TopicVar ] Block { orwith CtrlExp [ TopicVar ] Block } [ else Block ] .

TopicVar = "->" var .

/* Parenthesis here are part of the control structures' syntax. */
CtrlExp = ExpList | "(" ExpList ")". 

Return = return CtrlExp .

StatMod = ExpList ( cond_keyword | loop_keyword ) Cond .

Loop =   ForLoop
       | "loop"  [ LoopCondStats ] Block .
       | "while" CtrlExp           Block
       | "until" CtrlExp           Block

ForLoop = "for" CtrlExp [ TopicVars ] Block .

LoopCondStats = "(" [ ExpListStats ] ")" | ExpListStats .
ExpListStats  = [ ExpList ] ";" [ ExpList ] ";" [ ExpList ] .

LoopCtrl = ( "break" | "next" | "redo" | "goto" ) [ name | loop_id ] .

TopicVars = "->" var [ EqExp ] { "," var [ EqExp ] } .

DeferBlock = "defer" Block .
DeferExp   = "defer" Exp .

Try = "try" Block { "catch" Exp Block } [ "finally" Block ] .

Fn = [ "const" ] [ scope ] [ "mul" ] "fn" name [ "(" [ FnArgs ] ")" ] [ ":s" | ":g" ] FnBody .

FnArgs =   NormArg { "," NormArg } [ "," AccArg ] [ "," MapArg ]
         | AccArg "," MapArg
         | AccArg
         | MapArg .

NormArg = var [ ( "=" | "=//" ) Exp ] .
AccArg  = "*" var .
HashArg = "*" "*" var .

FnBody = Block .

Class    = [ "const" ] [ scope ] "class" name [ ClassRel ] [ main ] ClassBody .
ClassRel = Is | Does | Is Does .

Is   = ":is("   [ IsArgs   ] ")" .
Does = ":does(" [ DoesArgs ] ")" .

DoesArgs = IsArgs .

IsArgs   = RelClass { "," RelClass } .
RelClass = any_name | fq_name_main | PrefixExp .

ClassBody = "{" ( AttrsWithOthers | AttrsWithOthers end { end } MethsWithOthers ) "}" .

AttrsWithOthers   = { ClassNonBlockStat end { end } | BlockStat      } [ ClassNonBlockStat ] .
MethsWithOthers   = { NonBlockStat      end { end } | ClassBlockStat } [ NonBlockStat      ] .
ClassNonBlockStat = Field | NonBlockStat .
ClassBlockStat    = Meth  | BlockStat .

Field = "field" name [ ":rw" | ":ro" | ":built" ] [ EqExp ] .

Meth     = [ "mul" ] "meth" ( "<" custom_op ">" | name [ "(" [ FnArgs ] ")" ] ) [ ":io" ] MethBody .
MethBody = FnBody .

Role     = [ "const" ] [ scope ] "role" name [ Does ] [ main ] RoleBody .
RoleBody = ClassBody .

Exp =   nil
      | boolean
      | number
      | string_lit
      | regex_lit
      | PrefixExp
      | AnonyFn
      | Array
      | Map
      | VarDef
      | Exp infix_op Exp
      | Exp postfix_op
      | prefix_op Exp
      | StatExp

AnonyFn = [ "fn" ] "{" [ "|" FnArgs "|" ] [ Stats ] "}" .

Map        = DefaultMap | QuotedMap .
DefaultMap = "{" { Exp "=>" Exp Commas } "}" .
QuotedMap  = "@m" PairWordsPair .

PairWordsPair =   xxPair Words xxPair
                | xxPair Words xxPair
                | xxPair Words xxPair .

Words =  .

Array        = DefaultArray | QuotedArray .
DefaultArray = "[" [ ExpList ] "]" .
QoutedArray  = "@a" PairWordsPair .

StatExp = DoStatExp | MaStatExp .

DoStatExp = "do" ( Loop    | Flow   ) .
MaStatExp = "ma" ( ForLoop | FnCall ) .

PrefixExp =  .

/* Below are lexical tokens */

end = ";" .

infix_op = "," | ":" |

postfix_op = .

prefix_op = .

unimpl = "…" | "..." .

im   = ":i" .
main = ":m" .

nil = "nil" .

boolean = "true" | "false" .

number  = oct | hex | bin | decimal | integer .
oct     =
hex     =
bin     =
decimal =

cond_keyword = "if"  | "unless" | "when" | "with" | "given" .
loop_keyword = "for" | "until"  | "while" .
scope        = "let" | "our" .

nl = [ "\r" ] "\n" .

special_char = "$" | "v" | "o" | ","
                   | "/" | "|" | """"
                   | "$" | "0" | "("
                   | "<" | "f" | "*"
                   | "." | "!" .

name = 

var = name .

namespace = name { "::" name } .

fq_var      = namespace "::" name .
fq_var_main = [ namespace ] ":::" name .

special_var = "$" special_char .
any_var     = var | fq_var | special_var .

string_lit = string_default | string_with_pair | here_doc .

string_default = single_q | double_q | back_q .
single_q       = "'"  val_single_q "'" .
double_q       = """" val_double_q """" .
back_q         = "`"  val_single_q "`" .
val_double_q   = vsq .
val_single_q   = vdq .

vsq = .
vdq = .

string_with_pair = "@" ( single_q_p | double_q_p | back_q_p ) .
single_q_p       = "q" p__s_q__p .
double_q_p       = "Q" p__d_q__p .
back_q_p         = "x" p__b_q__p .

p__s_q__p =   o_cb   vsq c_cb   | o_pr   vsq c_pr   | o_sb vsq c_sb | o_lab vsq o_rab
            | o_ldap vsq c_rdap | o_lapq vsq c_lapq | s_em vsq s_em | s_bt  vsq s_bt
            | s_dl   vsq s_dl   | s_vb   vsq s_vb   | s_dq vsq s_sq | s_sq  vsq s_sq
            | s_sl   vsq s_sl   | s_cm   vsq s_cm .

p__d_q__p =   o_cb   vdq c_cb   | o_pr   vdq c_pr   | o_sb vdq c_sb | o_lab vdq o_rab
            | o_ldap vdq c_rdap | o_lapq vdq c_lapq | s_em vdq s_em | s_bt  vdq s_bt
            | s_dl   vdq s_dl   | s_vb   vdq s_vb   | s_dq vdq s_sq | s_sq  vdq s_sq
            | s_sl   vdq s_sl   | s_cm   vdq s_cm .

p__b_q__p = p__s_q__p .

o_cb  = "{" . c_cb  = "}" . o_pr   = "(" . c_pr   = ")" . o_sb   = "[" . c_sb   = "]" .
o_lab = "<" . c_rab = ">" . o_ldaq = "«" . c_rdap = "»" . o_labq = "‹" . c_rabq = "›" .

s_em = "!"  . s_bt = "`" . s_dl = "$" . s_vb = "|" .
s_dq = """" . s_sq = "'" . s_sl = "/" . s_cm = "," .

here_doc    = hd_no_q | hd_single_q | hd_double_q | hd_back_q .
hd_no_q     = "<<"      tok      nl vsq tok .
hd_single_q = "<<" "'"  tok "'"  nl vsq tok .
hd_double_q = "<<" """" tok """" nl vdq tok .
hd_back_q   = "<<" "`"  tok "`"  nl vsq tok .
tok         = name .

regex_lit         = regex_default | regex_q_with_pair .
regex_default     = "/" "/" { regex_val_mod } .
regex_q_with_pair = "@r"
regex_val_mod     = "m" | "i" | "s" | "a" | "n" |
regex_s_op_mod    = regex_value_mod | "g" | "e" |
```

An expession is a special case of statement that returns a value.

say ((2,,,4) + 1) # outputs 5 it implies that an expression list is an expression and ',' is an infix operator.
say ((2,,) + 1)   # outputs 3, is ',' also a postfix operator?
