# WSF of the Maat Programming Language

* `{X}` stands for 0 or more of `X`.
* `[X]` implies `X` is optional.
* `|` stands for alternation.
* `(X)` for grouping, `X` is considered a single unit.

```
Block = "{" [ Stats ] "}" .

Stats = { ( NonBlockStat end { end } | BlockStat ) } [ NonBlockStat ] .

NonBlockStat =   unimpl
               | Package
               | Use
               | Load
               | VarDef
               | Exp
               | StatMod
               | LoopCtrl
               | DeferExp
               | Return .

BlockStat =   PackageBlock
            | Label
            | Loop
            | Flow
            | Fn
            | Class
            | Role
            | Try
            | DeferBlock .

Package      = "package" namespace .
PackageBlock = Package Block .

Label = name ":" .

Use = "use" namespace [ "(" [ name { "," name } ] ")" ] .

Load = "load" string_lit .

Exps = Exp { Commas Exp } { "," } .

Commas = "," { "," } .

Return = return [ ExpList ] .

ExpList = Exps | "(" Exps ")" .

VarDef = ( [ "const" ] ( [ scope ] | "state" ) Vars | "const" Names | "temp" AnyVars ) [ EqExp ] .

EqExp = "=" Exp .

Vars    = "(" VarList { "," } ")" | var .
VarList = { Var_ } [ "*" ] var [ im ] { _Var } .
_Var    = Commas var [ im ] .
Var_    = var        [ im ] Commas .

AnyVars    = "(" AnyVarList { "," } ")" | any_var .
AnyVarList = { AnyVar_ } [ "*" ] any_var [ im ] { _AnyVar } .
_AnyVar    = Commas any_var [ im ] .
AnyVar_    = any_var        [ im ] Commas .

Flow =   "given" Cond [ TopicVar ] Block
       | "when"  Cond              Block
       | "if"    Cond [ TopicVar ] Block { elseif Cond [ TopicVar ] Block } [ else Block ]
       | "with"  Cond [ TopicVar ] Block { orwith Cond [ TopicVar ] Block } [ else Block ] .

TopicVar = "->" var .

Cond = ExpList | "(" ExpList ")". 

StatMod = ExpList ( cond_keyword | loop_keyword ) Cond .

Loop =   "for"   ExpList [ TopicVars ] Block
       | "while" Cond                  Block
       | "until" Cond                  Block
       | "loop"  [ LoopStats ]         Block .

LoopStats    = "(" [ ExpListStats ] ")" | ExpListStats .
ExpListStats = [ ExpList ] ";" [ ExpList ] ";" [ ExpList ] .

LoopCtrl = ( "break" | "next" | "redo" | "goto" ) [ name | loop_id ] .

TopicVars = "->" var [ EqExp ] { "," var [ EqExp ] } .

DeferBlock = "defer" Block .
DeferExp   = "defer" Exp .

Try = "try" Block { "catch" Exp Block } [ "finally" Block ] .

Fn = [ "const" ] [ scope ] [ "mul" ] "fn" name [ "(" [ FnArgs ] ")" ] [ ":s" | ":g" ] FnBody .

FnArgs =   NormArg { "," NormArg } [ "," AccArg ] [ "," MapArg ]
         | AccArg "," MapArg
         | AccArg
         | MapArg .

NormArg = var [ ( "=" | "=//" ) Exp ] .
AccArg  = "*" var .
HashArg = "*" "*" var .

FnBody = Block .

Class    = [ "const" ] [ scope ] "class" name [ ClassRel ] [ main ] ClassBody .
ClassRel = Is | Does | Is Does .

Is   = ":is("   [ IsArgs   ] ")" .
Does = ":does(" [ DoesArgs ] ")" .

DoesArgs = IsArgs .

IsArgs   = RelClass { "," RelClass } .
RelClass = any_name | fq_name_main | PrefixExp .

ClassBody = "{" ( AttrsWithOthers { end } | AttrsWithOthers end { end } MethsWithOthers ) "}" .

/* */
AttrsWithOthers = ( ClassAttr | Stat ) { ( end { end } ClassAttr | _Stat ) } .
MethsWithOthers = ( Method    | Stat ) { ( Method                | _Stat ) } .
Stat            = NonBlockStat | BlockStat .
_Stat           = end { end } Stat .

ClassAttr = "field" name [ ( ":rw" | ":ro" | ":built" ) ] [ EqExp ] .

Method     = [ "mul" ] "meth" name [ "(" [ FnArgs ] ")" ] [ ":io" ] MethodBody .
MethodBody = FnBody .

Role     = [ "const" ] [ scope ] "role" name [ Does ] [ main ] RoleBody .
RoleBody = ClassBody .

Exp =   nil
      | boolean
      | number
      | string_lit
      | regex_lit
      | PrefixExp
      | AnonyFn
      | Array
      | Map
      | VarDef
      | Exp infix_op Exp
      | Exp postfix_op
      | prefix_op Exp
      | StatExp

AnonyFn = [ "fn" ] "{" [ "|" FnArgs "|" ] [ Stats ] "}" .

Map = DefaultMap | QuotedMap .

Array = DefaultArray | QuotedArray .

StatExp = StatPrefix (Loop | Flow)

PrefixExp = 

/* Lexical tokens */

end = ";" .

infix_op = "," | ":"

unimpl = "â€¦" | "..." .

im   = ":i" .
main = ":m" .

nil = "nil" .

boolean = "true" | "false" .

number =

cond_keyword = "if"  | "unless" | "when" | "with" | "given" .
loop_keyword = "for" | "until"  | "while" .
scope        = "let" | "our" .

name = 

var = name .

namespace = name { "::" name } .

fq_var      = namespace "::" name .
fq_var_main = namespace ":::" name | ":::" name .

special_var = "$" name .
any_var     = var | fq_var | special_name .

string_lit = single_q | double_q | back_q | q_with_pairs | here_doc .
single_q   = 
double_q   =
back_q     =

q_with_pairs = 

here_doc          = no_q_here_doc | single_q_here_doc | double_q_here_doc | back_q_here_doc .
no_q_here_doc     = "<<" here_doc_tok
single_q_here_doc = "<<" "'" here_doc_tok "'"
double_q_here_doc =
back_q_here_doc   = "<<" "`" here_doc_tok "`"
here_doc_tok      = name .

regex_lit          = default_regex_lit | regex_q_with_pairs .
default_regex_lit  = "/" "/" regex_flags .
regex_q_with_pairs = 
regex_flags        =
```

An expession is a special case of statement that returns a value.

say ((2,,,4) + 1) # outputs 5 it implies that an expression list is an expression and ',' is an infix operator.
say ((2,,) + 1)   # outputs 3, is ',' also a postfix operator?
