# The Maat Application Programming Interface

The Maat programming language as it's written in C offers a C/C++ API, it's
basically a set of C functions, types and macros. All these entities are
declared in the `maat.h` header file. Conceptually, the API is divided into
two parts, the first is called the low level API and the second one is called
the high level API. All the functions in this API are reentrant as all the
information about Maat contexts are kept in a complex dynamic structure called
`Maa`.

Used via this API on your program, a `Maa` is just a VM-level blocking thread
that executes C code in a virtual stack but you can use functions in this API
to launch the execution of non-blocking Maat code scheduled by Maat's runtime
scheduler than runs in background in an OS-thread. Still via this API you can
use some functions to directly parse and run maat code and if at that time
your program was already in a multi-threaded environment initiated by function
calls from the maat library then the current thread(probably the main) on
which you called a run to the maat code becomes part of the thread pool used
by the scheduler to multiplex the execution of language threads including that
Maat code. This means the maat code will not run instantly if they were other
language threads on the queue but you'll probably never noticed a latency.


## Virtual Stack

Like most scripting language APIs, 

## Low level MAAT API.

## High level MAAT API (Mac: Maat programming in C)

Nothing was coded yet, these are just some thoughts on the high level API

1. Building complex data structures

Before calling for the allocation of these maat values, you have to register the
maatine on which the maat values will be created using the `Maa()` function like
so: `Maa(m)` where `m` is the initialized maatine.

`str_v("string"), sv("string")` returns a maat string value

`num_v(2), nv(2)` returns a maat number value

`bool_v(void *), bv()`: should be passed a pointer to a maat value.

`av(sv("one"), nv(2), av(bv(sv("")) ... )), arr_v(...)` returns the Maat array
value `["one", 2, [false, ["kueppo", nil, "tcheukueppo"]], "last"]`

```
Value *a = av(
   sv("one"),
   nv(2),
   av(
      bv(sv()),
      av(
         sv("kueppo"),
         nil,
         sv("tcheukueppo")
      )
   ),
   sv("last")
);
```

`map_v(sv("a"), av(iv(2), sv("one")), iv(29), sv("twenty nine")), mv(...)` returns the
Maat map value `{ a => [2, "one"], 29 => "twenty nine"}`.

Some variants which will require the Maat to parse code, generated bytecode and
execute it, all done in the thread that called the function, make sure code show
be very small enough to avoid latency.

`Value *k = m_value("[2, {one => [2, 10]}]")` returns the Maat value of what you
passed as argument.

```
Value *ar = av(m_value("{kueppo => 6}"), sv(2))
```

The above should return the maat value `[{kueppo => 6}, 2]`

`false` and `true` should return the maat true and false value respectively, this should
be option and it might cause issues with `stdbool.h`.

2. Accessing values

This should be very useful especially for complex maat data structures.

3. Method and function calls

With the high level API there's no concepts of virtuals, the API abstracts it away, the
API is fully object-oriented.

```
Val a = Av(Sv("one"), PVal("['kueppo', 'is', 'sleeping']"));

O(m,a)->at(1)->c(Join, Sv(" "))->c(Len)->say;

Maa(m) // registers the default maatine to be used by O()

// Output: k_u_e_o
// a[1][0].split('p').grep(:.len > 0).join('_').say;
O(a)->at(1,0)->c(Split, Sv("p"))->c(Grep, Fv(":.len > 0"))->c(Join, Sv("_"))->say;
```

`O(a)`: Hey! `a` is a Maat value and all maat values are objects, push `a` into the stack of the
default registered maatine `m` (`Maa(m)`).

`->at(1, 0)`: for assessing elements of complex structures, `at` is mainly for arrays, here it gets "kueppo"
if map counterparts is `->get(<key>)`. the result is now at the top of the stack.

`->c(split, Sv("p"))`: push Sv("p") onto the stack an call the the method `split` with the reciever the first
element in the stack. The next `->c` calls barely does the same thing for each method.

This abstracts away the virtual stack but things can really get messy because one can think of nesting `O` calls.

So how do you figure this out?

Val a = Av(true), b = Sv("kueppo");

```
#define Unshift "unshift"
#define Split   "split"

O(a)->c(Unshift, O(b)->c(Split, Sv())->v)->say; // Output: [["k", "u", "e", "p", "p", "o"], true]
```

Internally, this should

* Push `a` onto the stack.
* Prepare the call to unshift but Oups the argument makes an `O` call again so
* Push `b` onto the stack
* Prepare the call to split with the split call having an empty string as argument
* Call the split with `b` as reciever and push the result `["k", "u", "e", "p", "p", "o"]` onto the stack
* We now have the to unshift with the argument gotten via `->v` and so the call so we end up with the expected output.

The pointer to a structure is returned by the `O(...)` and this structure should look this

```
// This is just pseudo-code and nothing has been tested.

struct S {
    struct S *(*c) (const char *func_name, va_list argp); // the ->c method
    Value *v; // top of the stack value
    void * (*say) (void); // the ->say function
    void * (*dump) (void); // the ->say function
    struct S (*at) (var_list argp); // for accessing array elements.
    struct S (*get) (var_list argp); // for accessing map entries.
    // ....
}
```

This means that each `c(...)` should start a callframe for the method call with
the reciever at the start of the frame.

Now let's think on Using C arithmetics operator to perform arithmetic operations
on maat values, this is because having to use `->c` to perform arithmetic
operations in maat can be very cumbersome and also that arithmetic operations
in C is very unsafe.

```
Val a = Iv(2), b = Dv(2.30), c = Uv(~0ul);

                    // will not overflow here like (2ul + (~0ul))
Val res = Nv(N(b) * (N(a) + N(b)))
```

Still much to solve here will come back to it!

4. Control statements

```
Val a = PVal("['one', 2, @q(quoted string)]");

// given (m,a)
given (a) {
   when (nil) {
     say("a is nil");
     last;
   }
   when (sv(""))
}

```

```
Val m = Mv(Sv("one"), PVal("@a(I love Pinneaples)"))

if_ (Val v = O(m)->get("one")) {
   O(v)->c(Join, sv(" "))->say;
}
els {
   say("Hash m does not have key 'one'");
}
```

```
Val a = PVal("[[2, 1, 10]]"), b = PVal("[[3, 10, 39]]");

// foreach (m, a) {
foreach (a) (i) { say("{}", i); }}

/* Check if the number of rows equals the number of columns. */

if ( len(a) != len(O(b)->at(0)) ) {
   int i, col = (int)len(O(b)->at(0));
   Val res = Av();

   for (i = 0; i < len(a); i++) {
      int j;
      Val rs = Av();

      for (j = 0; j < col; j++) {
         int k;
         double sum = 0;

         for (k = 0; k < col; k++)
            sum += O(a)->nat(i,k) * O(b)->nat(k,j);

         O(rs)->c(Push, Nv(sum));
      }

      O(res)->c(Push, rs);
   }

   O(res)->say;
}

// foreach (m, map) (...) { to specify a maatine

Val map = PVal("{one => 1, two => 2}");

foreach (map) (k, v) {
    say("{1} => {2}", k, v);
}}
```

5. C Functions (`fn (fn_name) { ... }`)

6. Running Maat code

7. Maatines

8. Communication between C and a Maatine using a channel made with `cv(<size>)`

9. C maatines that uses threads in Maat's thread pools

10. GC helper



