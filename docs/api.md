# The Maat Application Programming Interface

The Maat programming language as it's written in C offers a C/C++ API, it's
basically a set of C functions, types and macros. All these entities are
declared in the `maat.h` header file. Conceptually, the API is divided into two
parts, the first is called the low level API and the second one is called the
high level API. All the functions in this API are reentrant since all the
information about Maat contexts are kept in a complex dynamic structure called
`Maa`.

Used via this API on your program, `Maa` is just a VM-level blocking thread that
executes C code in a virtual stack. You can use functions in this API to launch
the execution of non-blocking Maat code to be scheduled by Maat's runtime
scheduler running in background by an OS-thread of your program. Still via this
API, you can use some functions to directly parse and run maat code and if at
that time your program was already in a multi-threaded environment initiated by
function calls from this API, then the thread (probably the main) on which you
ran the maat code becomes part of the thread pool used by the scheduler to
multiplex the execution of language threads. This means the maat code will not
run instantly if they were other language threads on the queue but you'll
probably never noticed a latency.


## Virtual Stack

Like most scripting language APIs, 

## Low level MAAT API.

## High level MAAT API (Mac: Maat programming in C)

Nothing was coded yet, these are just some thoughts on the high level API

1. Building complex data structures

Before calling for the allocation of these maat values, you have to set the
maatine on which the maat values will be created using the `Maa()` function like
so: `Maa(m)` where `m` is the initialized maatine.

`Str("string")` returns a maat string value

`Iv(2), Dv(2.09)` Integer and Decimal values, returns a maat number value

`Bv(Val)`: Evaluate an return the boolean maat value of the values passed in argument

`Array(Str("one"), Iv(2), Array(Bv(Str("")) ... ))` returns the Maat array

value `["one", 2, [false, ["kueppo", nil, "tcheukueppo"]], "last"]`

```
Value *a = Array(
   Str("one"),
   Iv(2),
   Array(
      Bv(sv()),
      Array(
         Array("kueppo"),
         Nil,
         Str("tcheukueppo")
      )
   ),
   Str("last")
);
```

`Mv(sv("a"), Array(Iv(2), Str("one")), Iv(29), Str("twenty nine"))` returns the
Maat map value `{ a => [2, "one"], 29 => "twenty nine"}`.

Some variants which will require the Maat to parse code, generated bytecode and
execute it, all done in the thread that called the function, make sure code is
small enough to avoid latency.

`Val k = PVal("[2, {one => [2, 10]}]")` returns the Maat value of what you
passed as argument.

```
Val ar = Array(PVal("{kueppo => 6}"), Str(2))
```

The above should return the maat value `[{kueppo => 6}, 2]`

`false` and `true` should return the maat true and false value respectively, this should
be option and it might cause issues with `stdbool.h`.

2. Accessing values

This should be very useful especially for complex maat data structures.

3. Method and function calls

With the high level API there's no concepts of virtuals, the API abstracts it away and
provides a fully object-oriented API.

```
Val a = Array(Str("one"), PVal("['kueppo', 'is', 'sleeping']"));

O(m,a)->at(1)->call(m_join, Str(" "))->call(m_len)->say;

Maa(m) // registers the default maatine to be used by O()

// Output: k_u_e_o
// a[1][0].split('p').grep(:.len > 0).join('_').say;

O(a)->at(1,0)->call(m_split, Str("p"))->call(m_grep, Fn(":.len > 0"))->call(m_join, Str("_"))->say;
```

`O(a)`: Hey! `a` is a Maat value and all maat values are objects, push `a` into the stack of the
default registered maatine `m` (`Maa(m)`).

`->at(1, 0)`: to access elements of complex structures, `at` is mainly for arrays, here it gets "kueppo"
its map counterparts is `->get(<key>)`. the result is now at the top of the stack.

`->call(m_split, Str("p"))`: push Str("p") onto the stack and call the the method `split` with the reciever the first
element in the stack. The next `->c` calls barely does the same thing for each method.

This abstracts away the virtual stack but things can really get messy because one can think of nesting `O` calls.

So how do you figure this out?

Val a = Array(true), b = Str("kueppo");

```
#define m_unshift "unshift"
#define m_split   "split"

O(a)->call(m_unshift, O(b)->call(m_split, Str())->v)->say; // Output: [["k", "u", "e", "p", "p", "o"], true]
```

Internally, this should

* Push `a` onto the stack.
* Prepare the call to unshift but Oups the argument makes an `O` call again so
* Push `b` onto the stack
* Prepare the call to split with the split call having an empty string as argument
* Call the split with `b` as reciever and push the result `["k", "u", "e", "p", "p", "o"]` onto the stack
* We now have the to unshift with the argument gotten via `->v` and so the call so we end up with the expected output.

The pointer to a structure is returned by the `O(...)` and this structure should look this

```
// This is just pseudo-code and nothing has been tested.

struct S {
    struct S *(*c) (const char *func_name, va_list argp); // the ->c method
    Value *v; // top of the stack value
    void * (*say) (void); // the ->say function
    void * (*dump) (void); // the ->say function
    struct S (*at) (var_list argp); // for accessing array elements.
    struct S (*get) (var_list argp); // for accessing map entries.
    unsigned char (*bool) (void); // return 1 if the value at the top of the stack is a true value and 0 otherwise.
    // ....
}
```

This means that each `c(...)` should start a callframe for the method call with
the reciever at the start of the frame.

Now let's think of using C arithmetics operator to perform arithmetic operations
on maat values, this is because having to use `->c` to perform arithmetic
operations in maat can be very cumbersome. Also, arithmetic operations
in C is very unsafe.

```
Val a = Int(2), b = Dec(2.30), c = UInt(~0ul);

                    // will not overflow here like (2ul + (~0ul))
Val res = Nv(N(b) * (N(a) + N(b)))
```

Still much to solve here will come back to it!

4. Control statements

```
Val a = PVal("['one', 2, @q(quoted string)]");

// given (m,a)
given (a) {
   when (nil) {
     say("a is nil");
     last;
   }
   when (sv("")) {}
}

```

```
Val m = Map(Str("one"), PVal("@a(I love Pinneaples)"));

if (O(m).call(m_exists, "one").bool()) {
   O(m)->get("one")->call(m_join, Str(" "))->say;
}
else {
   say("Hash m does not have key 'one'");
}
```

```
with (...) {
}
orwith (...) {
}
else {
}
```

```
Val a = PVal("[[2, 1, 10]]"), b = PVal("[[3, 10, 39]]");

// foreach (m, a) {
foreach (a) (i) { say("{}", i); }}

/* Check if the number of rows equals the number of columns. */

Num col = ma_len(O(b)->at(0));
if ( ma_len(a) != col ) {
   int i;
   Val res = Array();

   for (i = 0; i < ma_len(a); i++) {
      int j;
      Val rs = Array();

      for (j = 0; j < col; j++) {
         int k;
         Num sum = 0;

         for (k = 0; k < col; k++)
            sum += O(a)->nat(i,k) * O(b)->nat(k,j);

         O(rs)->call(m_push, Nv(sum));
      }

      O(res)->call(m_push, rs);
   }

   O(res)->say;
}

// foreach (m, map) (...) { to specify a maatine

Val map = PVal("{one => 1, two => 2}");

foreach (map) (k, v) {
    say("{1} => {2}", k, v);
}}
```

5. C Functions (`fn (fn_name) { ... }`)

```
fn (func_name, maa) {
    ...
}
```

6. Running Maat code

7. Maatines

8. Communication between C and a Maatine using a channel made with `cv(<size>)`

9. C maatines that uses threads in Maat's thread pools for execution, this should be
   handle by the maat scheduler itself.


10. GC helper

You can attach references to heap allocated memories to the gc collector and ask for
a free whenever you want to. I think it can be nice to tag them with names but I doubt
on its performance impact.
